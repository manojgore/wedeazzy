/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/long";
exports.ids = ["vendor-chunks/long"];
exports.modules = {

/***/ "(action-browser)/./node_modules/long/umd/index.js":
/*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\nvar Long = function(exports1) {\n    \"use strict\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.default = void 0;\n    /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */ // WebAssembly optimizations to do native i64 multiplication and divide\n    var wasm = null;\n    try {\n        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n            0,\n            97,\n            115,\n            109,\n            1,\n            0,\n            0,\n            0,\n            1,\n            13,\n            2,\n            96,\n            0,\n            1,\n            127,\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            3,\n            7,\n            6,\n            0,\n            1,\n            1,\n            1,\n            1,\n            1,\n            6,\n            6,\n            1,\n            127,\n            1,\n            65,\n            0,\n            11,\n            7,\n            50,\n            6,\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            10,\n            191,\n            1,\n            6,\n            4,\n            0,\n            35,\n            0,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n        ])), {}).exports;\n    } catch (e) {}\n    /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */ function Long(low, high, unsigned) {\n        /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */ this.low = low | 0;\n        /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */ this.high = high | 0;\n        /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */ this.unsigned = !!unsigned;\n    } // The internal representation of a long is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // Javascript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within Javascript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */ Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\n        value: true\n    });\n    /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */ function isLong(obj) {\n        return (obj && obj[\"__isLong__\"]) === true;\n    }\n    /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */ function ctz32(value) {\n        var c = Math.clz32(value & -value);\n        return value ? 31 - c : c;\n    }\n    /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */ Long.isLong = isLong;\n    /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */ var INT_CACHE = {};\n    /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */ var UINT_CACHE = {};\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromInt(value, unsigned) {\n        var obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromInt = fromInt;\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? UZERO : ZERO;\n        if (unsigned) {\n            if (value < 0) return UZERO;\n            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n        }\n        if (value < 0) return fromNumber(-value, unsigned).neg();\n        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromNumber = fromNumber;\n    /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromBits = fromBits;\n    /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n    /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */ function fromString(str, unsigned, radix) {\n        if (str.length === 0) throw Error(\"empty string\");\n        if (typeof unsigned === \"number\") {\n            // For goog.math.long compatibility\n            radix = unsigned;\n            unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        var p;\n        if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n        else if (p === 0) {\n            return fromString(str.substring(1), unsigned, radix).neg();\n        } // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\n        var result = ZERO;\n        for(var i = 0; i < str.length; i += 8){\n            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                var power = fromNumber(pow_dbl(radix, size));\n                result = result.mul(power).add(fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromString = fromString;\n    /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromValue(val, unsigned) {\n        if (typeof val === \"number\") return fromNumber(val, unsigned);\n        if (typeof val === \"string\") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n        return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */ Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n    // no runtime penalty for these.\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_16_DBL = 1 << 16;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_24_DBL = 1 << 24;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ZERO = fromInt(0);\n    /**\n   * Signed zero.\n   * @type {!Long}\n   */ Long.ZERO = ZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UZERO = fromInt(0, true);\n    /**\n   * Unsigned zero.\n   * @type {!Long}\n   */ Long.UZERO = UZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ONE = fromInt(1);\n    /**\n   * Signed one.\n   * @type {!Long}\n   */ Long.ONE = ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UONE = fromInt(1, true);\n    /**\n   * Unsigned one.\n   * @type {!Long}\n   */ Long.UONE = UONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var NEG_ONE = fromInt(-1);\n    /**\n   * Signed negative one.\n   * @type {!Long}\n   */ Long.NEG_ONE = NEG_ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n    /**\n   * Maximum signed value.\n   * @type {!Long}\n   */ Long.MAX_VALUE = MAX_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n    /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n    /**\n   * Minimum signed value.\n   * @type {!Long}\n   */ Long.MIN_VALUE = MIN_VALUE;\n    /**\n   * @alias Long.prototype\n   * @inner\n   */ var LongPrototype = Long.prototype;\n    /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toInt = function toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toNumber = function toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */ LongPrototype.toString = function toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            // Unsigned Longs are never negative\n            if (this.eq(MIN_VALUE)) {\n                // We need to change the Long value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        } // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n        var result = \"\";\n        while(true){\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) return digits + result;\n            else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    };\n    /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */ LongPrototype.getHighBits = function getHighBits() {\n        return this.high;\n    };\n    /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n        return this.high >>> 0;\n    };\n    /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */ LongPrototype.getLowBits = function getLowBits() {\n        return this.low;\n    };\n    /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n        return this.low >>> 0;\n    };\n    /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        var val = this.high != 0 ? this.high : this.low;\n        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n        return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isZero = function isZero() {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */ LongPrototype.eqz = LongPrototype.isZero;\n    /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isNegative = function isNegative() {\n        return !this.unsigned && this.high < 0;\n    };\n    /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isPositive = function isPositive() {\n        return this.unsigned || this.high >= 0;\n    };\n    /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isOdd = function isOdd() {\n        return (this.low & 1) === 1;\n    };\n    /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isEven = function isEven() {\n        return (this.low & 1) === 0;\n    };\n    /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.equals = function equals(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    };\n    /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.eq = LongPrototype.equals;\n    /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.notEquals = function notEquals(other) {\n        return !this.eq(/* validates */ other);\n    };\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.neq = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ne = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThan = function lessThan(other) {\n        return this.comp(/* validates */ other) < 0;\n    };\n    /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lt = LongPrototype.lessThan;\n    /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    };\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThan = function greaterThan(other) {\n        return this.comp(/* validates */ other) > 0;\n    };\n    /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gt = LongPrototype.greaterThan;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n        return this.comp(/* validates */ other) >= 0;\n    };\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.compare = function compare(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.eq(other)) return 0;\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.comp = LongPrototype.compare;\n    /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */ LongPrototype.negate = function negate() {\n        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n        return this.not().add(ONE);\n    };\n    /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */ LongPrototype.neg = LongPrototype.negate;\n    /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */ LongPrototype.add = function add(addend) {\n        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = addend.high >>> 16;\n        var b32 = addend.high & 0xFFFF;\n        var b16 = addend.low >>> 16;\n        var b00 = addend.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 + b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.subtract = function subtract(subtrahend) {\n        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    };\n    /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.sub = LongPrototype.subtract;\n    /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.multiply = function multiply(multiplier) {\n        if (this.isZero()) return this;\n        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n        if (wasm) {\n            var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = multiplier.high >>> 16;\n        var b32 = multiplier.high & 0xFFFF;\n        var b16 = multiplier.low >>> 16;\n        var b00 = multiplier.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.mul = LongPrototype.multiply;\n    /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.divide = function divide(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        if (divisor.isZero()) throw Error(\"division by zero\"); // use wasm support if present\n        if (wasm) {\n            // guard against signed division overflow: the largest\n            // negative number / -1 would be 1 larger than the largest\n            // positive number, due to two's complement.\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                // be consistent with non-wasm code path\n                return this;\n            }\n            var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n        var approx, rem, res;\n        if (!this.unsigned) {\n            // This section is only relevant for signed longs and is derived from the\n            // closure library as a whole.\n            if (this.eq(MIN_VALUE)) {\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n                else if (divisor.eq(MIN_VALUE)) return ONE;\n                else {\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                    var halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(ZERO)) {\n                        return divisor.isNegative() ? ONE : NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = ZERO;\n        } else {\n            // The algorithm below has not been made for unsigned longs. It's therefore\n            // required to take special care of the MSB prior to running it.\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return UZERO;\n            if (divisor.gt(this.shru(1))) return UONE;\n            res = UZERO;\n        } // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        rem = this;\n        while(rem.gte(divisor)){\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            } // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) approxRes = ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    };\n    /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.div = LongPrototype.divide;\n    /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.modulo = function modulo(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n        if (wasm) {\n            var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    };\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.mod = LongPrototype.modulo;\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.rem = LongPrototype.modulo;\n    /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */ LongPrototype.not = function not() {\n        return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countLeadingZeros = function countLeadingZeros() {\n        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.clz = LongPrototype.countLeadingZeros;\n    /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countTrailingZeros = function countTrailingZeros() {\n        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    };\n    /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.and = function and(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.or = function or(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.xor = function xor(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shl = LongPrototype.shiftLeft;\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRight = function shiftRight(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr = LongPrototype.shiftRight;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateLeft = function rotateLeft(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotl = LongPrototype.rotateLeft;\n    /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateRight = function rotateRight(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotr = LongPrototype.rotateRight;\n    /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */ LongPrototype.toSigned = function toSigned() {\n        if (!this.unsigned) return this;\n        return fromBits(this.low, this.high, false);\n    };\n    /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */ LongPrototype.toUnsigned = function toUnsigned() {\n        if (this.unsigned) return this;\n        return fromBits(this.low, this.high, true);\n    };\n    /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */ LongPrototype.toBytes = function toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */ LongPrototype.toBytesLE = function toBytesLE() {\n        var hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    };\n    /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */ LongPrototype.toBytesBE = function toBytesBE() {\n        var hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    };\n    /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    };\n    /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    var _default = Long;\n    exports1.default = _default;\n    return \"default\" in exports1 ? exports1.default : exports1;\n}({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return Long;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb25nL3VtZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrRkFBK0I7QUFDL0IsSUFBSUEsT0FBTyxTQUFVQyxRQUFPO0lBQzFCO0lBRUFDLE9BQU9DLGNBQWMsQ0FBQ0YsVUFBUyxjQUFjO1FBQzNDRyxPQUFPO0lBQ1Q7SUFDQUgsU0FBUUksT0FBTyxHQUFHLEtBQUs7SUFFdkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCQyxHQUNELHVFQUF1RTtJQUN2RSxJQUFJQyxPQUFPO0lBRVgsSUFBSTtRQUNGQSxPQUFPLElBQUlDLFlBQVlDLFFBQVEsQ0FBQyxJQUFJRCxZQUFZRSxNQUFNLENBQUMsSUFBSUMsV0FBVztZQUFDO1lBQUc7WUFBSTtZQUFLO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUc7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUc7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUc7WUFBRztZQUFJO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFLO1NBQUcsSUFBSSxDQUFDLEdBQUdULE9BQU87SUFD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QU8sR0FBR0o7QUFDbEQsRUFBRyxDQUFDO0FBQ0osSUFBSSxJQUEwQyxFQUFFb0wsaUNBQU8sRUFBRSxtQ0FBRTtJQUFhLE9BQU9yTDtBQUFNLENBQUM7QUFBQSxrR0FBQztLQUNsRixFQUFxRkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGFtcGh1Yi8uL25vZGVfbW9kdWxlcy9sb25nL3VtZC9pbmRleC5qcz9kYzQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVC5cbnZhciBMb25nID0gKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuICBcbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICAgKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICpcbiAgICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgICovXG4gIC8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG4gIHZhciB3YXNtID0gbnVsbDtcbiAgXG4gIHRyeSB7XG4gICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMV0pKSwge30pLmV4cG9ydHM7XG4gIH0gY2F0Y2ggKGUpIHsvLyBubyB3YXNtIHN1cHBvcnQgOihcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cbiAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gICAqIEBleHBvcnRzIExvbmdcbiAgICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXG4gIFxuICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICBcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH0gLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbiAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4gIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbiAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4gIC8vXG4gIC8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbiAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4gIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAvLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4gIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbiAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvL1xuICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbiAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cbiAgXG4gIC8qKlxuICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAY29uc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBudW1iZXJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgXG4gIGZ1bmN0aW9uIGN0ejMyKHZhbHVlKSB7XG4gICAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmcuaXNMb25nID0gaXNMb25nO1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgSU5UX0NBQ0hFID0ge307XG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVSU5UX0NBQ0hFID0ge307XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gIFxuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgdmFsdWUgPj4+PSAwO1xuICBcbiAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHtcbiAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICB9XG4gIFxuICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIDAsIHRydWUpO1xuICAgICAgaWYgKGNhY2hlKSBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlIHw9IDA7XG4gIFxuICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkge1xuICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICBcbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcbiAgICAgIGlmIChjYWNoZSkgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIFxuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gIFxuICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICAgIHJldHVybiBmcm9tQml0cyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCB8IDAsIHVuc2lnbmVkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXG4gICAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcbiAgXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XG4gICAgICByYWRpeCA9IHVuc2lnbmVkO1xuICAgICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgIH1cbiAgXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgdmFyIHA7XG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKSB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7ZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICB9IC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuICAgIHZhciByZXN1bHQgPSBaRVJPO1xuICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICBcbiAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7IC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIFxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7IC8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbiAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XG4gIC8qKlxuICAgKiBTaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuWkVSTyA9IFpFUk87XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBVbnNpZ25lZCB6ZXJvLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5VWkVSTyA9IFVaRVJPO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgT05FID0gZnJvbUludCgxKTtcbiAgLyoqXG4gICAqIFNpZ25lZCBvbmUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk9ORSA9IE9ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuICAvKipcbiAgICogVW5zaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5VT05FID0gVU9ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcbiAgLyoqXG4gICAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcbiAgLyoqXG4gICAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG4gIC8qKlxuICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuICAvKipcbiAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuICcwJztcbiAgXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXG4gICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxuICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIH0gZWxzZSByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIFxuICBcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgICAgIHJlbSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcbiAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgaWYgKHJlbS5pc1plcm8oKSkgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KSBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gIFxuICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93O1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gIFxuICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkgYnJlYWs7XG4gIFxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAhdGhpcy5lcShcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcik7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPCAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpIDw9IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPiAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICBpZiAodGhpcy5lcShvdGhlcikpIHJldHVybiAwO1xuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykgcmV0dXJuIC0xO1xuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykgcmV0dXJuIDE7IC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcbiAgXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXG4gIFxuICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xuICAvKipcbiAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBNSU5fVkFMVUU7XG4gICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XG4gIH07XG4gIC8qKlxuICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKSBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG4gIFxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xuICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKyBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEzMiArIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKyBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzO1xuICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKSBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIHZhciBsb3cgPSB3YXNtW1wibXVsXCJdKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICBcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO2Vsc2UgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxuICBcbiAgXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cbiAgXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xuICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICAgKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7IC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBcbiAgICBpZiAod2FzbSkge1xuICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XG4gICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wiZGl2X3VcIl0gOiB3YXNtW1wiZGl2X3NcIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xuICBcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcbiAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpIHJldHVybiBNSU5fVkFMVUU7IC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIE9ORTtlbHNlIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgXG4gICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgXG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcbiAgXG4gICAgICByZXMgPSBaRVJPO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cbiAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpIHJldHVybiBVWkVSTztcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICAgIHJldHVybiBVT05FO1xuICAgICAgcmVzID0gVVpFUk87XG4gICAgfSAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICBcbiAgXG4gICAgcmVtID0gdGhpcztcbiAgXG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcbiAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOyAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXG4gIFxuICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcbiAgICAgICAgICBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuICAgICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgXG4gICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xuICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgIH0gLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgXG4gIFxuICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkgYXBwcm94UmVzID0gT05FO1xuICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7IC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBcbiAgICBpZiAod2FzbSkge1xuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID8gTWF0aC5jbHozMih0aGlzLmhpZ2gpIDogTWF0aC5jbHozMih0aGlzLmxvdykgKyAzMjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudFRyYWlsaW5nWmVyb3N9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY3R6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3M7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtlbHNlIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztlbHNlIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtlbHNlIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gbnVtQml0cyAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHtcbiAgICB2YXIgYjtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBcbiAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgbnVtQml0cyAtPSAzMjtcbiAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlTGVmdH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGwgPSBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xuICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgIHJldHVybiBbbG8gJiAweGZmLCBsbyA+Pj4gOCAmIDB4ZmYsIGxvID4+PiAxNiAmIDB4ZmYsIGxvID4+PiAyNCwgaGkgJiAweGZmLCBoaSA+Pj4gOCAmIDB4ZmYsIGhpID4+PiAxNiAmIDB4ZmYsIGhpID4+PiAyNF07XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgIHJldHVybiBbaGkgPj4+IDI0LCBoaSA+Pj4gMTYgJiAweGZmLCBoaSA+Pj4gOCAmIDB4ZmYsIGhpICYgMHhmZiwgbG8gPj4+IDI0LCBsbyA+Pj4gMTYgJiAweGZmLCBsbyA+Pj4gOCAmIDB4ZmYsIGxvICYgMHhmZl07XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgIHJldHVybiBuZXcgTG9uZyhieXRlc1s0XSA8PCAyNCB8IGJ5dGVzWzVdIDw8IDE2IHwgYnl0ZXNbNl0gPDwgOCB8IGJ5dGVzWzddLCBieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7XG4gIH07XG4gIFxuICB2YXIgX2RlZmF1bHQgPSBMb25nO1xuICBleHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbiAgcmV0dXJuIFwiZGVmYXVsdFwiIGluIGV4cG9ydHMgPyBleHBvcnRzLmRlZmF1bHQgOiBleHBvcnRzO1xufSkoe30pO1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvbmc7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IExvbmc7XG4iXSwibmFtZXMiOlsiTG9uZyIsImV4cG9ydHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVmYXVsdCIsIndhc20iLCJXZWJBc3NlbWJseSIsIkluc3RhbmNlIiwiTW9kdWxlIiwiVWludDhBcnJheSIsImUiLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJwcm90b3R5cGUiLCJfX2lzTG9uZ19fIiwiaXNMb25nIiwib2JqIiwiY3R6MzIiLCJjIiwiTWF0aCIsImNsejMyIiwiSU5UX0NBQ0hFIiwiVUlOVF9DQUNIRSIsImZyb21JbnQiLCJjYWNoZWRPYmoiLCJjYWNoZSIsImZyb21CaXRzIiwiZnJvbU51bWJlciIsImlzTmFOIiwiVVpFUk8iLCJaRVJPIiwiVFdPX1BXUl82NF9EQkwiLCJNQVhfVU5TSUdORURfVkFMVUUiLCJUV09fUFdSXzYzX0RCTCIsIk1JTl9WQUxVRSIsIk1BWF9WQUxVRSIsIm5lZyIsIlRXT19QV1JfMzJfREJMIiwibG93Qml0cyIsImhpZ2hCaXRzIiwicG93X2RibCIsInBvdyIsImZyb21TdHJpbmciLCJzdHIiLCJyYWRpeCIsImxlbmd0aCIsIkVycm9yIiwiUmFuZ2VFcnJvciIsInAiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwicmFkaXhUb1Bvd2VyIiwicmVzdWx0IiwiaSIsInNpemUiLCJtaW4iLCJwYXJzZUludCIsInBvd2VyIiwibXVsIiwiYWRkIiwiZnJvbVZhbHVlIiwidmFsIiwiVFdPX1BXUl8xNl9EQkwiLCJUV09fUFdSXzI0X0RCTCIsIlRXT19QV1JfMjQiLCJPTkUiLCJVT05FIiwiTkVHX09ORSIsIkxvbmdQcm90b3R5cGUiLCJ0b0ludCIsInRvTnVtYmVyIiwidG9TdHJpbmciLCJpc1plcm8iLCJpc05lZ2F0aXZlIiwiZXEiLCJyYWRpeExvbmciLCJkaXYiLCJyZW0xIiwic3ViIiwicmVtIiwicmVtRGl2IiwiaW50dmFsIiwiZGlnaXRzIiwiZ2V0SGlnaEJpdHMiLCJnZXRIaWdoQml0c1Vuc2lnbmVkIiwiZ2V0TG93Qml0cyIsImdldExvd0JpdHNVbnNpZ25lZCIsImdldE51bUJpdHNBYnMiLCJiaXQiLCJlcXoiLCJpc1Bvc2l0aXZlIiwiaXNPZGQiLCJpc0V2ZW4iLCJlcXVhbHMiLCJvdGhlciIsIm5vdEVxdWFscyIsIm5lcSIsIm5lIiwibGVzc1RoYW4iLCJjb21wIiwibHQiLCJsZXNzVGhhbk9yRXF1YWwiLCJsdGUiLCJsZSIsImdyZWF0ZXJUaGFuIiwiZ3QiLCJncmVhdGVyVGhhbk9yRXF1YWwiLCJndGUiLCJnZSIsImNvbXBhcmUiLCJ0aGlzTmVnIiwib3RoZXJOZWciLCJuZWdhdGUiLCJub3QiLCJhZGRlbmQiLCJhNDgiLCJhMzIiLCJhMTYiLCJhMDAiLCJiNDgiLCJiMzIiLCJiMTYiLCJiMDAiLCJjNDgiLCJjMzIiLCJjMTYiLCJjMDAiLCJzdWJ0cmFjdCIsInN1YnRyYWhlbmQiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJkaXZpZGUiLCJkaXZpc29yIiwiYXBwcm94IiwicmVzIiwiaGFsZlRoaXMiLCJzaHIiLCJzaGwiLCJ0b1Vuc2lnbmVkIiwic2hydSIsIm1heCIsImZsb29yIiwibG9nMiIsImNlaWwiLCJsb2ciLCJMTjIiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsIm1vZHVsbyIsIm1vZCIsImNvdW50TGVhZGluZ1plcm9zIiwiY2x6IiwiY291bnRUcmFpbGluZ1plcm9zIiwiY3R6IiwiYW5kIiwib3IiLCJ4b3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91Iiwicm90YXRlTGVmdCIsImIiLCJyb3RsIiwicm90YXRlUmlnaHQiLCJyb3RyIiwidG9TaWduZWQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiaGkiLCJsbyIsImZyb21CeXRlcyIsImJ5dGVzIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSIsIl9kZWZhdWx0IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/long/umd/index.js\n");

/***/ })

};
;